================================================================================
ULTRA-DEFENSIVE FIX FOR RIDES-MASTHEAD AND EATS-MASTHEAD DUPLICATION
================================================================================

üéØ CHECKPOINT INFO:
Current safe commit: 53ba4d106759d17bdc0f0bd78a0a558d9829c73c
To restore: git checkout 53ba4d106759d17bdc0f0bd78a0a558d9829c73c

================================================================================
REPLACE THE copySectionsToPage FUNCTION (starting around line 575)
================================================================================

Replace the entire copySectionsToPage function with this ULTRA-DEFENSIVE version:

*/

// =============================================================================
// SECTION COPYING LOGIC - ULTRA-DEFENSIVE VERSION
// =============================================================================

async function copySectionsToPage(targetPage, sectionNames, sourceSections, rowNumber) {
  console.log('\nüîíüîíüîí ROW ' + rowNumber + ' START (ULTRA-DEFENSIVE MODE) üîíüîíüîí');
  console.log('Target page: ' + targetPage.name);
  console.log('Sections to copy: ' + sectionNames.join(', '));

  // üîí CRITICAL: Lock to target page and verify
  figma.currentPage = targetPage;
  console.log('‚úÖ Current page locked to: ' + figma.currentPage.name);

  // Track successful and failed sections
  const successfulSections = [];
  const permanentFailures = [];

  // Position tracking
  let currentX = CONFIG.PAGE_MARGIN;
  let currentY = CONFIG.PAGE_MARGIN;
  let rowHeight = 0;

  // =============================================================================
  // PROCESS EACH SECTION WITH ULTRA-DEFENSIVE SAFEGUARDS
  // =============================================================================
  for (let i = 0; i < sectionNames.length; i++) {
    const sectionName = sectionNames[i];

    console.log('\n‚îÅ‚îÅ‚îÅ Section ' + (i + 1) + '/' + sectionNames.length + ': ' + sectionName + ' ‚îÅ‚îÅ‚îÅ');

    // Find section in source
    const sourceSection = sourceSections.find(function (section) {
      return section.name === sectionName;
    });

    if (!sourceSection) {
      console.log('‚ö†Ô∏è SKIP: Not found in source');
      permanentFailures.push({
        name: sectionName,
        reason: 'Section not found in source file'
      });
      // Reserve space
      currentX += 300 + CONFIG.SECTION_SPACING;
      continue;
    }

    // üîí SAFEGUARD 1: Re-lock page before EVERY section
    console.log('üîí Pre-clone page lock: ' + targetPage.name);
    figma.currentPage = targetPage;
    
    // Verify lock
    if (figma.currentPage !== targetPage) {
      console.error('‚ùå CRITICAL: Failed to lock page! Skipping section.');
      permanentFailures.push({
        name: sectionName,
        reason: 'Failed to lock target page'
      });
      currentX += sourceSection.width + CONFIG.SECTION_SPACING;
      continue;
    }

    try {
      // üîí SAFEGUARD 2: Get source page reference
      const sourcePage = sourceSection.node.parent;
      console.log('üìç Source section location: ' + (sourcePage ? sourcePage.name : 'NO PARENT'));

      // üîí SAFEGUARD 3: Clone with immediate verification
      console.log('üîÑ Cloning section...');
      const clonedSection = sourceSection.node.clone();
      
      console.log('‚úÖ Clone created');
      console.log('üìç Current page after clone: ' + figma.currentPage.name);
      console.log('üìç Clone parent after clone: ' + (clonedSection.parent ? clonedSection.parent.name : 'NO PARENT'));

      // üîí SAFEGUARD 4: CRITICAL - If clone has wrong parent, REMOVE IT IMMEDIATELY
      if (clonedSection.parent && clonedSection.parent !== targetPage) {
        console.error('üö® WRONG PARENT DETECTED: ' + clonedSection.parent.name);
        console.log('üßπ Removing clone from wrong parent...');
        clonedSection.remove();
        console.log('‚ùå Clone removed from ' + clonedSection.parent.name);
        
        // Re-clone after cleanup
        console.log('üîÑ Re-cloning after cleanup...');
        figma.currentPage = targetPage; // Re-lock
        const reclonedSection = sourceSection.node.clone();
        
        // Verify re-clone
        if (reclonedSection.parent && reclonedSection.parent !== targetPage) {
          console.error('üö® RE-CLONE STILL HAS WRONG PARENT! Permanent failure.');
          reclonedSection.remove();
          throw new Error('Clone created on wrong page despite safeguards');
        }
        
        // Use the re-cloned section
        clonedSection = reclonedSection;
        console.log('‚úÖ Re-clone successful with correct parent');
      }

      // üîí SAFEGUARD 5: Force page lock again before positioning
      figma.currentPage = targetPage;

      // üîí SAFEGUARD 6: Set position
      clonedSection.x = currentX;
      clonedSection.y = currentY;
      console.log('üìç Position set: (' + currentX + ', ' + currentY + ')');

      // üîí SAFEGUARD 7: Append to target page with verification
      if (clonedSection.parent !== targetPage) {
        console.log('üìå Appending to target page...');
        targetPage.appendChild(clonedSection);
        console.log('‚úÖ Appended successfully');
      } else {
        console.log('‚úÖ Already on target page');
      }

      // üîí SAFEGUARD 8: Final verification
      if (clonedSection.parent !== targetPage) {
        throw new Error('Clone not on target page after appendChild');
      }

      console.log('‚úÖ‚úÖ‚úÖ SUCCESS: "' + sectionName + '" copied successfully');

      // Track success
      successfulSections.push({
        name: sectionName,
        width: sourceSection.width,
        height: sourceSection.height
      });

      // Update position for next section
      rowHeight = Math.max(rowHeight, sourceSection.height);
      currentX += sourceSection.width + CONFIG.SECTION_SPACING;

    } catch (error) {
      console.error('‚ùå FAILED: "' + sectionName + '"');
      console.error('   Error: ' + error.message);
      console.error('   Stack: ' + error.stack);

      // Track permanent failure
      permanentFailures.push({
        name: sectionName,
        reason: error.message
      });

      // üîí SAFEGUARD 9: Cleanup any orphaned clones on Source_Template
      console.log('üßπ Checking for orphaned clones on source page...');
      try {
        const allPages = figma.root.children;
        for (let p = 0; p < allPages.length; p++) {
          const page = allPages[p];
          if (page.type === 'PAGE' && (page.name === 'Source_Template' || page.name === 'MASTER TEMPLATES')) {
            const orphanedSections = page.findAll(function(node) {
              return node.type === 'SECTION' && node.name === sectionName;
            });
            
            // If there are MORE than 1 of this section (the original), remove extras
            if (orphanedSections.length > 1) {
              console.log('üö® Found ' + orphanedSections.length + ' copies of "' + sectionName + '" on ' + page.name);
              console.log('üßπ Removing ' + (orphanedSections.length - 1) + ' orphaned clones...');
              
              for (let o = 1; o < orphanedSections.length; o++) {
                orphanedSections[o].remove();
                console.log('   ‚úÖ Removed orphaned clone ' + o);
              }
            }
          }
        }
      } catch (cleanupError) {
        console.error('   ‚ö†Ô∏è Cleanup failed: ' + cleanupError.message);
      }

      // Reserve space for failed section
      currentX += sourceSection.width + CONFIG.SECTION_SPACING;

      // Send warning to UI
      figma.ui.postMessage({
        type: 'warning',
        message: '‚ö†Ô∏è Failed to copy "' + sectionName + '" in row ' + rowNumber
      });
    }

    // üîí SAFEGUARD 10: Verify we're still on correct page after section
    if (figma.currentPage !== targetPage) {
      console.warn('‚ö†Ô∏è Page drift detected after section ' + (i + 1) + '! Forcing back...');
      figma.currentPage = targetPage;
    }
  }

  // =============================================================================
  // Final Summary
  // =============================================================================
  console.log('\nüèÅüèÅüèÅ ROW ' + rowNumber + ' COMPLETE üèÅüèÅüèÅ');
  console.log('üìä Final Summary:');
  console.log('   ‚úÖ Successful: ' + successfulSections.length + '/' + sectionNames.length);
  console.log('   ‚ùå Failed: ' + permanentFailures.length + '/' + sectionNames.length);

  if (permanentFailures.length > 0) {
    console.log('\n‚ö†Ô∏è Failed sections:');
    permanentFailures.forEach(function (failure) {
      console.log('   - ' + failure.name + ': ' + failure.reason);
    });
  }

  console.log(''); // Empty line for readability
}

/*
================================================================================
END OF REPLACEMENT
================================================================================

üîß WHAT THIS FIX DOES:

1. **Page Locking**: Forces page to target before EVERY operation
2. **Parent Verification**: Checks clone parent immediately after creation
3. **Wrong Parent Cleanup**: Removes clone if it's on wrong page, re-clones
4. **Orphan Cleanup**: Searches Source_Template for duplicates and removes them
5. **Multiple Verification Points**: Verifies page context at 10 different points
6. **Detailed Logging**: Shows exactly where and when things go wrong
7. **No Retry Loop**: Uses immediate fix approach instead of retry logic
8. **Space Reservation**: Maintains layout even if section fails

üéØ THIS SHOULD FIX:

‚úÖ Sections failing to copy to new pages
‚úÖ Duplicates appearing on Source_Template
‚úÖ Font-related failures (by removing and re-cloning)
‚úÖ Empty spaces where sections should be (still leaves space for layout consistency)

üí° AFTER APPLYING THIS FIX:

1. Test with a row containing Rides-Masthead
2. Check console for detailed logging
3. Verify no duplicates on Source_Template
4. If still failing, console will show exactly where

================================================================================
