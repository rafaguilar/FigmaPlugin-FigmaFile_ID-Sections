BACKUP OF copySectionsToPage FUNCTION - BEFORE SOURCE_TEMPLATE CORRUPTION FIX
================================================================================

Current Git Hash: 53ba4d106759d17bdc0f0bd78a0a558d9829c73c

To restore this version:
git checkout 53ba4d106759d17bdc0f0bd78a0a558d9829c73c

Or manually restore this function by copying it back into code.js

================================================================================

async function copySectionsToPage(targetPage, sectionNames, sourceSections, rowNumber) {
  console.log('\n=== ROW ' + rowNumber + ' START ===');
  console.log('Target page: ' + targetPage.name);
  console.log('Sections to copy: ' + sectionNames.join(', '));

  // Force page switch
  figma.currentPage = targetPage;
  console.log('Current page set to: ' + figma.currentPage.name);

  // Track successful and failed sections
  const successfulSections = [];
  const failedSections = [];
  const permanentFailures = [];

  // Position tracking
  let currentX = CONFIG.PAGE_MARGIN;
  let currentY = CONFIG.PAGE_MARGIN;
  let rowHeight = 0;

  // =============================================================================
  // PASS 1: Initial copy attempt for all sections
  // =============================================================================
  console.log('\n=== PASS 1: Initial Copy Attempt ===');
  console.log('Attempting to copy ' + sectionNames.length + ' sections...\n');

  for (let i = 0; i < sectionNames.length; i++) {
    const sectionName = sectionNames[i];

    console.log('--- Section ' + (i + 1) + '/' + sectionNames.length + ': ' + sectionName + ' ---');

    // Find section in source
    const sourceSection = sourceSections.find(function (section) {
      return section.name === sectionName;
    });

    if (!sourceSection) {
      console.log('‚ö†Ô∏è SKIP: Not found in source');
      permanentFailures.push({
        name: sectionName,
        reason: 'Section not found in source file'
      });
      continue;
    }

    // Ensure we're on the correct page before cloning
    if (figma.currentPage !== targetPage) {
      console.warn('‚ö†Ô∏è Page drift detected! Switching back to target page...');
      figma.currentPage = targetPage;
    }

    console.log('üìã Attempting to clone \"' + sectionName + '\"...');

    try {
      // Clone the section
      const clonedSection = sourceSection.node.clone();

      // Verify page didn't change after clone
      if (figma.currentPage !== targetPage) {
        console.error('‚ùå Clone changed current page! Forcing switch back...');
        figma.currentPage = targetPage;
      }

      // Set position
      clonedSection.x = currentX;
      clonedSection.y = currentY;

      // Append to target page
      targetPage.appendChild(clonedSection);

      console.log('‚úÖ SUCCESS: \"' + sectionName + '\" copied');

      // Track success
      successfulSections.push({
        name: sectionName,
        width: sourceSection.width,
        height: sourceSection.height
      });

      // Update position for next section
      rowHeight = Math.max(rowHeight, sourceSection.height);
      currentX += sourceSection.width + CONFIG.SECTION_SPACING;

    } catch (error) {
      console.warn('‚ö†Ô∏è FAILED (will retry): \"' + sectionName + '\"');
      console.warn('   Error: ' + error.message);

      // Track failure for retry
      failedSections.push({
        name: sectionName,
        sourceSection: sourceSection,
        error: error.message
      });

      // Reserve space to maintain layout consistency
      currentX += sourceSection.width + CONFIG.SECTION_SPACING;
    }
  }

  console.log('\n--- Pass 1 Summary ---');
  console.log('‚úÖ Successful: ' + successfulSections.length);
  console.log('‚ö†Ô∏è Failed (will retry): ' + failedSections.length);
  console.log('‚ùå Not found: ' + permanentFailures.length);

  // =============================================================================
  // PASS 2: Retry failed sections
  // =============================================================================
  if (failedSections.length > 0) {
    console.log('\n=== PASS 2: Retry Failed Sections ===');
    console.log('Retrying ' + failedSections.length + ' failed sections...\n');

    // Send UI notification about retry
    figma.ui.postMessage({
      type: 'status',
      message: 'üîÑ Retrying ' + failedSections.length + ' failed sections for row ' + rowNumber + '...'
    });

    // Reset position to start of row for retries
    currentX = CONFIG.PAGE_MARGIN;

    for (let i = 0; i < failedSections.length; i++) {
      const failedItem = failedSections[i];
      const sectionName = failedItem.name;
      const sourceSection = failedItem.sourceSection;

      console.log('--- Retry ' + (i + 1) + '/' + failedSections.length + ': ' + sectionName + ' ---');

      // Calculate position (skip already successful sections)
      let retryX = CONFIG.PAGE_MARGIN;
      for (let j = 0; j < sectionNames.length; j++) {
        if (sectionNames[j] === sectionName) {
          break;
        }
        const prevSection = sourceSections.find(function (s) { return s.name === sectionNames[j]; });
        if (prevSection) {
          retryX += prevSection.width + CONFIG.SECTION_SPACING;
        }
      }

      // Ensure we're on the correct page
      if (figma.currentPage !== targetPage) {
        console.warn('‚ö†Ô∏è Page drift detected! Switching back to target page...');
        figma.currentPage = targetPage;
      }

      console.log('üìã Retry attempt for \"' + sectionName + '\"...');

      try {
        // Clone the section
        const clonedSection = sourceSection.node.clone();

        // Verify page didn't change
        if (figma.currentPage !== targetPage) {
          console.error('‚ùå Clone changed current page! Forcing switch back...');
          figma.currentPage = targetPage;
        }

        // Set position
        clonedSection.x = retryX;
        clonedSection.y = currentY;

        // Append to target page
        targetPage.appendChild(clonedSection);

        console.log('‚úÖ SUCCESS on retry: \"' + sectionName + '\" copied');

        // Track success
        successfulSections.push({
          name: sectionName,
          width: sourceSection.width,
          height: sourceSection.height
        });

        // Update row height
        rowHeight = Math.max(rowHeight, sourceSection.height);

        // Send success notification
        figma.ui.postMessage({
          type: 'status',
          message: '‚úÖ Retry successful: \"' + sectionName + '\"'
        });

      } catch (retryError) {
        console.error('‚ùå RETRY FAILED: \"' + sectionName + '\"');
        console.error('   Error: ' + retryError.message);

        // Track permanent failure
        permanentFailures.push({
          name: sectionName,
          reason: 'Failed after retry: ' + retryError.message
        });

        // Send warning notification
        figma.ui.postMessage({
          type: 'warning',
          message: '‚ö†Ô∏è Permanently skipped \"' + sectionName + '\" after retry failed'
        });
      }
    }

    console.log('\n--- Pass 2 Summary ---');
    console.log('‚úÖ Successful retries: ' + (successfulSections.length - (sectionNames.length - failedSections.length - permanentFailures.length)));
    console.log('‚ùå Permanent failures: ' + permanentFailures.length);
  }

  // =============================================================================
  // Final Summary
  // =============================================================================
  console.log('\n=== ROW ' + rowNumber + ' COMPLETE ===');
  console.log('üìä Final Summary:');
  console.log('   ‚úÖ Total successful: ' + successfulSections.length + '/' + sectionNames.length);
  console.log('   ‚ùå Total failed: ' + permanentFailures.length + '/' + sectionNames.length);

  if (permanentFailures.length > 0) {
    console.log('\n‚ö†Ô∏è Permanently failed sections:');
    permanentFailures.forEach(function (failure) {
      console.log('   - ' + failure.name + ': ' + failure.reason);
    });
  }

  console.log(''); // Empty line for readability
}
